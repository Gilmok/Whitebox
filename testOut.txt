Done getting all 30 code paths.
=======================================
BlockType:0
AbsLineNo:0
RelLineNo:0
ParentLine:0
nPaths:256
--------------------------------
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			 else 
				 branchPos = line.indexOf(" if(");
			 branchPos = -1;
			 branchPos = -1;
			 branchPos = -1;
			 branchPos = -1;
			 
			 //if you end a block, add the block to the list and return
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }
--------------------------------
=======================================
############ End of level ####################
=======================================
BlockType:-1
AbsLineNo:120
RelLineNo:41
ParentLine:0
nPaths:8
--------------------------------
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
--------------------------------
=======================================
=======================================
BlockType:-1
AbsLineNo:22
RelLineNo:22
ParentLine:0
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:-1
AbsLineNo:26
RelLineNo:25
ParentLine:0
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:-1
AbsLineNo:39
RelLineNo:27
ParentLine:0
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:-1
AbsLineNo:41
RelLineNo:28
ParentLine:0
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:-1
AbsLineNo:43
RelLineNo:29
ParentLine:0
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:-1
AbsLineNo:55
RelLineNo:31
ParentLine:0
nPaths:2
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:-1
AbsLineNo:59
RelLineNo:32
ParentLine:0
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:-1
AbsLineNo:70
RelLineNo:34
ParentLine:0
nPaths:2
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:-1
AbsLineNo:74
RelLineNo:35
ParentLine:0
nPaths:2
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:-1
AbsLineNo:95
RelLineNo:37
ParentLine:0
nPaths:2
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:-1
AbsLineNo:99
RelLineNo:38
ParentLine:0
nPaths:2
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:-1
AbsLineNo:157
RelLineNo:42
ParentLine:0
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:-1
AbsLineNo:163
RelLineNo:47
ParentLine:0
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:-1
AbsLineNo:22
RelLineNo:22
ParentLine:0
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:-1
AbsLineNo:26
RelLineNo:25
ParentLine:0
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:-1
AbsLineNo:39
RelLineNo:27
ParentLine:0
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:-1
AbsLineNo:41
RelLineNo:28
ParentLine:0
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:-1
AbsLineNo:43
RelLineNo:29
ParentLine:0
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:-1
AbsLineNo:59
RelLineNo:32
ParentLine:0
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:-1
AbsLineNo:74
RelLineNo:35
ParentLine:0
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:-1
AbsLineNo:99
RelLineNo:38
ParentLine:0
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:-1
AbsLineNo:157
RelLineNo:42
ParentLine:0
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:-1
AbsLineNo:163
RelLineNo:47
ParentLine:0
nPaths:1
--------------------------------
--------------------------------
=======================================
############ End of level ####################
=======================================
BlockType:4
AbsLineNo:122
RelLineNo:2
ParentLine:120
nPaths:2
--------------------------------
			   /* value is 0: */
			 	  --------------------------------
=======================================
=======================================
BlockType:1
AbsLineNo:136
RelLineNo:6
ParentLine:120
nPaths:1
--------------------------------
			 	  /* because(line.indexOf("{") >= 0) */
			 	   {
			 	      blockType = 0;
			 	      
			 	   }
--------------------------------
=======================================
=======================================
BlockType:1
AbsLineNo:141
RelLineNo:7
ParentLine:120
nPaths:1
--------------------------------
			 	   else/* because(line.trim().endsWith(";")) */
			 		  endedBlock = true;
--------------------------------
=======================================
=======================================
BlockType:1
AbsLineNo:146
RelLineNo:11
ParentLine:120
nPaths:1
--------------------------------
			 	  /* because(line.indexOf("}") >= 0) */
			 		   endedBlock = true;
--------------------------------
=======================================
=======================================
BlockType:2
AbsLineNo:136
RelLineNo:6
ParentLine:120
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:2
AbsLineNo:141
RelLineNo:7
ParentLine:120
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:2
AbsLineNo:146
RelLineNo:11
ParentLine:120
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:1
AbsLineNo:22
RelLineNo:22
ParentLine:0
nPaths:1
--------------------------------
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
--------------------------------
=======================================
=======================================
BlockType:1
AbsLineNo:26
RelLineNo:25
ParentLine:0
nPaths:1
--------------------------------
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
--------------------------------
=======================================
=======================================
BlockType:1
AbsLineNo:39
RelLineNo:27
ParentLine:0
nPaths:1
--------------------------------
			/* because(line.startsWith("else")) */
				 branchPos = 0;
--------------------------------
=======================================
=======================================
BlockType:1
AbsLineNo:41
RelLineNo:28
ParentLine:0
nPaths:1
--------------------------------
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
--------------------------------
=======================================
=======================================
BlockType:1
AbsLineNo:43
RelLineNo:29
ParentLine:0
nPaths:1
--------------------------------
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
--------------------------------
=======================================
=======================================
BlockType:1
AbsLineNo:55
RelLineNo:31
ParentLine:0
nPaths:1
--------------------------------
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
--------------------------------
=======================================
=======================================
BlockType:2
AbsLineNo:55
RelLineNo:31
ParentLine:0
nPaths:1
--------------------------------
			 /*else*/
				 branchPos = line.indexOf(" switch(");
--------------------------------
=======================================
=======================================
BlockType:1
AbsLineNo:59
RelLineNo:32
ParentLine:0
nPaths:1
--------------------------------
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
--------------------------------
=======================================
=======================================
BlockType:1
AbsLineNo:70
RelLineNo:34
ParentLine:0
nPaths:1
--------------------------------
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
--------------------------------
=======================================
=======================================
BlockType:2
AbsLineNo:70
RelLineNo:34
ParentLine:0
nPaths:1
--------------------------------
			 /*else*/
				 branchPos = line.indexOf(" case ");
--------------------------------
=======================================
=======================================
BlockType:1
AbsLineNo:74
RelLineNo:35
ParentLine:0
nPaths:2
--------------------------------
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
			 }
--------------------------------
=======================================
=======================================
BlockType:1
AbsLineNo:95
RelLineNo:37
ParentLine:0
nPaths:1
--------------------------------
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
--------------------------------
=======================================
=======================================
BlockType:2
AbsLineNo:95
RelLineNo:37
ParentLine:0
nPaths:1
--------------------------------
			 /*else*/
				 branchPos = line.indexOf(" default:");
--------------------------------
=======================================
=======================================
BlockType:1
AbsLineNo:99
RelLineNo:38
ParentLine:0
nPaths:2
--------------------------------
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
			 }
--------------------------------
=======================================
=======================================
BlockType:1
AbsLineNo:157
RelLineNo:42
ParentLine:0
nPaths:1
--------------------------------
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
--------------------------------
=======================================
=======================================
BlockType:1
AbsLineNo:163
RelLineNo:47
ParentLine:0
nPaths:1
--------------------------------
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
--------------------------------
=======================================
=======================================
BlockType:2
AbsLineNo:22
RelLineNo:22
ParentLine:0
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:2
AbsLineNo:26
RelLineNo:25
ParentLine:0
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:2
AbsLineNo:39
RelLineNo:27
ParentLine:0
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:2
AbsLineNo:41
RelLineNo:28
ParentLine:0
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:2
AbsLineNo:43
RelLineNo:29
ParentLine:0
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:2
AbsLineNo:59
RelLineNo:32
ParentLine:0
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:2
AbsLineNo:74
RelLineNo:35
ParentLine:0
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:2
AbsLineNo:99
RelLineNo:38
ParentLine:0
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:2
AbsLineNo:157
RelLineNo:42
ParentLine:0
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:2
AbsLineNo:163
RelLineNo:47
ParentLine:0
nPaths:1
--------------------------------
--------------------------------
=======================================
############ End of level ####################
=======================================
BlockType:-1
AbsLineNo:123
RelLineNo:1
ParentLine:122
nPaths:2
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:-1
AbsLineNo:130
RelLineNo:2
ParentLine:122
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:-1
AbsLineNo:123
RelLineNo:1
ParentLine:122
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:-1
AbsLineNo:130
RelLineNo:2
ParentLine:122
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:-1
AbsLineNo:78
RelLineNo:4
ParentLine:74
nPaths:2
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:-1
AbsLineNo:103
RelLineNo:4
ParentLine:99
nPaths:2
--------------------------------
--------------------------------
=======================================
############ End of level ####################
=======================================
BlockType:1
AbsLineNo:123
RelLineNo:1
ParentLine:122
nPaths:2
--------------------------------
			      /* because(line.indexOf("}") >= 0) */
			       {
			       }
--------------------------------
=======================================
=======================================
BlockType:1
AbsLineNo:130
RelLineNo:2
ParentLine:122
nPaths:1
--------------------------------
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
--------------------------------
=======================================
=======================================
BlockType:2
AbsLineNo:123
RelLineNo:1
ParentLine:122
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:2
AbsLineNo:130
RelLineNo:2
ParentLine:122
nPaths:1
--------------------------------
--------------------------------
=======================================
=======================================
BlockType:1
AbsLineNo:78
RelLineNo:4
ParentLine:74
nPaths:1
--------------------------------
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
--------------------------------
=======================================
=======================================
BlockType:2
AbsLineNo:78
RelLineNo:4
ParentLine:74
nPaths:1
--------------------------------
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
--------------------------------
=======================================
=======================================
BlockType:1
AbsLineNo:103
RelLineNo:4
ParentLine:99
nPaths:1
--------------------------------
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
--------------------------------
=======================================
=======================================
BlockType:2
AbsLineNo:103
RelLineNo:4
ParentLine:99
nPaths:1
--------------------------------
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
--------------------------------
=======================================
############ End of level ####################
=======================================
BlockType:-1
AbsLineNo:125
RelLineNo:2
ParentLine:123
nPaths:2
--------------------------------
--------------------------------
=======================================
############ End of level ####################
=======================================
BlockType:1
AbsLineNo:125
RelLineNo:2
ParentLine:123
nPaths:1
--------------------------------
			    	  /* because(blockDepth == 0) */
			    	      endedBlock = true;
--------------------------------
=======================================
=======================================
BlockType:2
AbsLineNo:125
RelLineNo:2
ParentLine:123
nPaths:1
--------------------------------
			    	   /*else*/
			    		  blockDepth--;
--------------------------------
=======================================
############ End of level ####################
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	  /* because(blockDepth == 0) */
			    	      endedBlock = true;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	  /* because(blockDepth == 0) */
			    	      endedBlock = true;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	  /* because(blockDepth == 0) */
			    	      endedBlock = true;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	  /* because(blockDepth == 0) */
			    	      endedBlock = true;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	  /* because(blockDepth == 0) */
			    	      endedBlock = true;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	  /* because(blockDepth == 0) */
			    	      endedBlock = true;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	  /* because(blockDepth == 0) */
			    	      endedBlock = true;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	  /* because(blockDepth == 0) */
			    	      endedBlock = true;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	  /* because(blockDepth == 0) */
			    	      endedBlock = true;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	  /* because(blockDepth == 0) */
			    	      endedBlock = true;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	  /* because(blockDepth == 0) */
			    	      endedBlock = true;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	  /* because(blockDepth == 0) */
			    	      endedBlock = true;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	  /* because(blockDepth == 0) */
			    	      endedBlock = true;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	  /* because(blockDepth == 0) */
			    	      endedBlock = true;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	  /* because(blockDepth == 0) */
			    	      endedBlock = true;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	  /* because(blockDepth == 0) */
			    	      endedBlock = true;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	  /* because(blockDepth == 0) */
			    	      endedBlock = true;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	  /* because(blockDepth == 0) */
			    	      endedBlock = true;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	  /* because(blockDepth == 0) */
			    	      endedBlock = true;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	  /* because(blockDepth == 0) */
			    	      endedBlock = true;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	  /* because(blockDepth == 0) */
			    	      endedBlock = true;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	  /* because(blockDepth == 0) */
			    	      endedBlock = true;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	  /* because(blockDepth == 0) */
			    	      endedBlock = true;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	  /* because(blockDepth == 0) */
			    	      endedBlock = true;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	  /* because(blockDepth == 0) */
			    	      endedBlock = true;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	  /* because(blockDepth == 0) */
			    	      endedBlock = true;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	  /* because(blockDepth == 0) */
			    	      endedBlock = true;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	  /* because(blockDepth == 0) */
			    	      endedBlock = true;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	  /* because(blockDepth == 0) */
			    	      endedBlock = true;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	  /* because(blockDepth == 0) */
			    	      endedBlock = true;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	  /* because(blockDepth == 0) */
			    	      endedBlock = true;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	  /* because(blockDepth == 0) */
			    	      endedBlock = true;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	   /*else*/
			    		  blockDepth--;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	   /*else*/
			    		  blockDepth--;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	   /*else*/
			    		  blockDepth--;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	   /*else*/
			    		  blockDepth--;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	   /*else*/
			    		  blockDepth--;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	   /*else*/
			    		  blockDepth--;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	   /*else*/
			    		  blockDepth--;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	   /*else*/
			    		  blockDepth--;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	   /*else*/
			    		  blockDepth--;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	   /*else*/
			    		  blockDepth--;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	   /*else*/
			    		  blockDepth--;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	   /*else*/
			    		  blockDepth--;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	   /*else*/
			    		  blockDepth--;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	   /*else*/
			    		  blockDepth--;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	   /*else*/
			    		  blockDepth--;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	   /*else*/
			    		  blockDepth--;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	   /*else*/
			    		  blockDepth--;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	   /*else*/
			    		  blockDepth--;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	   /*else*/
			    		  blockDepth--;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	   /*else*/
			    		  blockDepth--;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	   /*else*/
			    		  blockDepth--;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	   /*else*/
			    		  blockDepth--;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	   /*else*/
			    		  blockDepth--;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	   /*else*/
			    		  blockDepth--;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	   /*else*/
			    		  blockDepth--;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	   /*else*/
			    		  blockDepth--;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	   /*else*/
			    		  blockDepth--;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	   /*else*/
			    		  blockDepth--;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	   /*else*/
			    		  blockDepth--;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	   /*else*/
			    		  blockDepth--;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	   /*else*/
			    		  blockDepth--;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			   /* value is 0: */
			      /* because(line.indexOf("}") >= 0) */
			       {
			    	   /*else*/
			    		  blockDepth--;
			       }
			       else/* because(line.indexOf("{") >= 0) */
			    	   blockDepth++;
			 	  
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	  /* because(line.indexOf("{") >= 0) */
			 	   {
			 	      blockType = 0;
			 	      
			 	   }
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	  /* because(line.indexOf("{") >= 0) */
			 	   {
			 	      blockType = 0;
			 	      
			 	   }
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	  /* because(line.indexOf("{") >= 0) */
			 	   {
			 	      blockType = 0;
			 	      
			 	   }
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	  /* because(line.indexOf("{") >= 0) */
			 	   {
			 	      blockType = 0;
			 	      
			 	   }
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	  /* because(line.indexOf("{") >= 0) */
			 	   {
			 	      blockType = 0;
			 	      
			 	   }
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	  /* because(line.indexOf("{") >= 0) */
			 	   {
			 	      blockType = 0;
			 	      
			 	   }
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	  /* because(line.indexOf("{") >= 0) */
			 	   {
			 	      blockType = 0;
			 	      
			 	   }
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	  /* because(line.indexOf("{") >= 0) */
			 	   {
			 	      blockType = 0;
			 	      
			 	   }
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	  /* because(line.indexOf("{") >= 0) */
			 	   {
			 	      blockType = 0;
			 	      
			 	   }
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	  /* because(line.indexOf("{") >= 0) */
			 	   {
			 	      blockType = 0;
			 	      
			 	   }
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	  /* because(line.indexOf("{") >= 0) */
			 	   {
			 	      blockType = 0;
			 	      
			 	   }
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	  /* because(line.indexOf("{") >= 0) */
			 	   {
			 	      blockType = 0;
			 	      
			 	   }
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	  /* because(line.indexOf("{") >= 0) */
			 	   {
			 	      blockType = 0;
			 	      
			 	   }
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	  /* because(line.indexOf("{") >= 0) */
			 	   {
			 	      blockType = 0;
			 	      
			 	   }
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	  /* because(line.indexOf("{") >= 0) */
			 	   {
			 	      blockType = 0;
			 	      
			 	   }
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	  /* because(line.indexOf("{") >= 0) */
			 	   {
			 	      blockType = 0;
			 	      
			 	   }
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	  /* because(line.indexOf("{") >= 0) */
			 	   {
			 	      blockType = 0;
			 	      
			 	   }
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	  /* because(line.indexOf("{") >= 0) */
			 	   {
			 	      blockType = 0;
			 	      
			 	   }
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	  /* because(line.indexOf("{") >= 0) */
			 	   {
			 	      blockType = 0;
			 	      
			 	   }
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	  /* because(line.indexOf("{") >= 0) */
			 	   {
			 	      blockType = 0;
			 	      
			 	   }
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	  /* because(line.indexOf("{") >= 0) */
			 	   {
			 	      blockType = 0;
			 	      
			 	   }
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	  /* because(line.indexOf("{") >= 0) */
			 	   {
			 	      blockType = 0;
			 	      
			 	   }
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	  /* because(line.indexOf("{") >= 0) */
			 	   {
			 	      blockType = 0;
			 	      
			 	   }
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	  /* because(line.indexOf("{") >= 0) */
			 	   {
			 	      blockType = 0;
			 	      
			 	   }
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	  /* because(line.indexOf("{") >= 0) */
			 	   {
			 	      blockType = 0;
			 	      
			 	   }
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	  /* because(line.indexOf("{") >= 0) */
			 	   {
			 	      blockType = 0;
			 	      
			 	   }
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	  /* because(line.indexOf("{") >= 0) */
			 	   {
			 	      blockType = 0;
			 	      
			 	   }
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	  /* because(line.indexOf("{") >= 0) */
			 	   {
			 	      blockType = 0;
			 	      
			 	   }
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	  /* because(line.indexOf("{") >= 0) */
			 	   {
			 	      blockType = 0;
			 	      
			 	   }
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	  /* because(line.indexOf("{") >= 0) */
			 	   {
			 	      blockType = 0;
			 	      
			 	   }
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	  /* because(line.indexOf("{") >= 0) */
			 	   {
			 	      blockType = 0;
			 	      
			 	   }
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	  /* because(line.indexOf("{") >= 0) */
			 	   {
			 	      blockType = 0;
			 	      
			 	   }
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	   else/* because(line.trim().endsWith(";")) */
			 		  endedBlock = true;
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	   else/* because(line.trim().endsWith(";")) */
			 		  endedBlock = true;
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	   else/* because(line.trim().endsWith(";")) */
			 		  endedBlock = true;
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	   else/* because(line.trim().endsWith(";")) */
			 		  endedBlock = true;
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	   else/* because(line.trim().endsWith(";")) */
			 		  endedBlock = true;
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	   else/* because(line.trim().endsWith(";")) */
			 		  endedBlock = true;
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	   else/* because(line.trim().endsWith(";")) */
			 		  endedBlock = true;
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	   else/* because(line.trim().endsWith(";")) */
			 		  endedBlock = true;
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	   else/* because(line.trim().endsWith(";")) */
			 		  endedBlock = true;
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	   else/* because(line.trim().endsWith(";")) */
			 		  endedBlock = true;
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	   else/* because(line.trim().endsWith(";")) */
			 		  endedBlock = true;
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	   else/* because(line.trim().endsWith(";")) */
			 		  endedBlock = true;
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	   else/* because(line.trim().endsWith(";")) */
			 		  endedBlock = true;
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	   else/* because(line.trim().endsWith(";")) */
			 		  endedBlock = true;
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	   else/* because(line.trim().endsWith(";")) */
			 		  endedBlock = true;
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	   else/* because(line.trim().endsWith(";")) */
			 		  endedBlock = true;
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	   else/* because(line.trim().endsWith(";")) */
			 		  endedBlock = true;
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	   else/* because(line.trim().endsWith(";")) */
			 		  endedBlock = true;
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	   else/* because(line.trim().endsWith(";")) */
			 		  endedBlock = true;
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	   else/* because(line.trim().endsWith(";")) */
			 		  endedBlock = true;
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	   else/* because(line.trim().endsWith(";")) */
			 		  endedBlock = true;
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	   else/* because(line.trim().endsWith(";")) */
			 		  endedBlock = true;
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	   else/* because(line.trim().endsWith(";")) */
			 		  endedBlock = true;
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	   else/* because(line.trim().endsWith(";")) */
			 		  endedBlock = true;
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	   else/* because(line.trim().endsWith(";")) */
			 		  endedBlock = true;
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	   else/* because(line.trim().endsWith(";")) */
			 		  endedBlock = true;
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	   else/* because(line.trim().endsWith(";")) */
			 		  endedBlock = true;
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	   else/* because(line.trim().endsWith(";")) */
			 		  endedBlock = true;
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	   else/* because(line.trim().endsWith(";")) */
			 		  endedBlock = true;
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	   else/* because(line.trim().endsWith(";")) */
			 		  endedBlock = true;
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	   else/* because(line.trim().endsWith(";")) */
			 		  endedBlock = true;
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	   else/* because(line.trim().endsWith(";")) */
			 		  endedBlock = true;
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	  /* because(line.indexOf("}") >= 0) */
			 		   endedBlock = true;
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	  /* because(line.indexOf("}") >= 0) */
			 		   endedBlock = true;
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	  /* because(line.indexOf("}") >= 0) */
			 		   endedBlock = true;
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	  /* because(line.indexOf("}") >= 0) */
			 		   endedBlock = true;
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	  /* because(line.indexOf("}") >= 0) */
			 		   endedBlock = true;
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	  /* because(line.indexOf("}") >= 0) */
			 		   endedBlock = true;
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	  /* because(line.indexOf("}") >= 0) */
			 		   endedBlock = true;
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	  /* because(line.indexOf("}") >= 0) */
			 		   endedBlock = true;
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	  /* because(line.indexOf("}") >= 0) */
			 		   endedBlock = true;
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	  /* because(line.indexOf("}") >= 0) */
			 		   endedBlock = true;
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	  /* because(line.indexOf("}") >= 0) */
			 		   endedBlock = true;
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	  /* because(line.indexOf("}") >= 0) */
			 		   endedBlock = true;
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	  /* because(line.indexOf("}") >= 0) */
			 		   endedBlock = true;
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	  /* because(line.indexOf("}") >= 0) */
			 		   endedBlock = true;
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	  /* because(line.indexOf("}") >= 0) */
			 		   endedBlock = true;
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	  /* because(line.indexOf("}") >= 0) */
			 		   endedBlock = true;
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	  /* because(line.indexOf("}") >= 0) */
			 		   endedBlock = true;
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	  /* because(line.indexOf("}") >= 0) */
			 		   endedBlock = true;
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	  /* because(line.indexOf("}") >= 0) */
			 		   endedBlock = true;
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	  /* because(line.indexOf("}") >= 0) */
			 		   endedBlock = true;
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	  /* because(line.indexOf("}") >= 0) */
			 		   endedBlock = true;
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	  /* because(line.indexOf("}") >= 0) */
			 		   endedBlock = true;
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	  /* because(line.indexOf("}") >= 0) */
			 		   endedBlock = true;
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	  /* because(line.indexOf("}") >= 0) */
			 		   endedBlock = true;
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	  /* because(line.indexOf("}") >= 0) */
			 		   endedBlock = true;
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	  /* because(line.indexOf("}") >= 0) */
			 		   endedBlock = true;
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	  /* because(line.indexOf("}") >= 0) */
			 		   endedBlock = true;
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	  /* because(line.indexOf("}") >= 0) */
			 		   endedBlock = true;
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	  /* because(line.indexOf("}") >= 0) */
			 		   endedBlock = true;
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	  /* because(line.indexOf("}") >= 0) */
			 		   endedBlock = true;
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	  /* because(line.indexOf("}") >= 0) */
			 		   endedBlock = true;
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	  /* because(line.indexOf("}") >= 0) */
			 		   endedBlock = true;
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("switch(")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("case ")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			/* because(line.startsWith("default:")) */
				 branchPos = 0;
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				/* because(blockType == 4) */  // don't process cases within cases
				 {
					 paths.add(currPath);
					 return paths;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
       private synchronized LinkedList processCodePath(LinkedList paths, String[] meth, int lineNo, int blockType, int parentLineNo)
	   {
		  //add the new entry
		  /*if(pathDepth > -1)
			  paths.add(new String((String) paths.get(pathDepth)));
		  else*/
		  //paths.add(new String("|L:" + lineNo + "|P:" + parentLineNo +"|\n"));
		  String currPath = new String("BT:" + blockType + "|L:" + pcpLineNo + "|R:" + lineNo + "|P:" + parentLineNo +"|\n");
		  boolean endedBlock = false;
		  String line;
		  int branchPos = -1;
		  int blockDepth = 0;
		  int relativeLine = 0;
		  int parLine = pcpLineNo;
		  int i = 0;
		  while(pcpLineNo < meth.length)
		  {
			 i = pcpLineNo;
			 line = new String(meth[i]);
			 line = WhiteboxUtils.removeNonCode(line, true);
			 //line = line.trim();
			 //if you start a new block, process it
			/* because(line.startsWith("if(")) */
				 branchPos = 0;
			 else 
				 branchPos = line.indexOf(" if(");
			/* because(branchPos > -1) */
			 {
				 //if block
				 //branchPos += 4;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 String condition = meth[i].substring(branchPos, ifEnd);
				 condition = condition.substring(condition.indexOf("if(") + 2);
				 meth[i] = meth[i].substring(0, branchPos) + "/* because" + condition + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 1, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			/* because(line.startsWith("else")) */
				 branchPos = 0;
			 else/* because(line.endsWith("else")) */
				 branchPos = line.indexOf("else");
			/* because(branchPos > -1) */
			 {
				 //else block
				 //branchPos += 5;
				 //int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 4) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/*else*/";
				 relativeLine--;
				 processCodePath(paths, meth, relativeLine, 2, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" switch(");
			/* because(branchPos > -1) */
			 {
				//switch block
				 //branchPos += 8;
				 int ifEnd = WhiteboxUtils.findClosingParen(line, branchPos + 8) + 1;
				 meth[i] = meth[i].substring(0, branchPos) + "/* switch on " + meth[i].substring(branchPos + 7, ifEnd) + " */" + meth[i].substring(ifEnd);
				 processCodePath(paths, meth, relativeLine, 3, parLine);
				 relativeLine++;
				 continue;
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" case ");
			/* because(branchPos > -1) */
			 {
				//case block
				 //branchPos += 6;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 6) + 1;
					 int caseEnd = line.indexOf("case ") + 5;
					 meth[i] = meth[i].substring(0, branchPos) + "/* value is " + meth[i].substring(caseEnd, ifEnd)  + " */" + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 4, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 branchPos = -1;
			 /*else*/
				 branchPos = line.indexOf(" default:");
			/* because(branchPos > -1) */
			 {
				//default block
				 //branchPos += 7;
				 /*else*/
				 {
					 int ifEnd = line.indexOf(":", branchPos + 7) + 1;
					 meth[i] = meth[i].substring(0, branchPos) + meth[i].substring(ifEnd);
					 relativeLine = 2;
					 processCodePath(paths, meth, relativeLine, 5, parLine);
					 relativeLine++;
					 continue;
				 }
			 }
			 
			 //if you end a block, add the block to the list and return
			/* switch on (blockType) */
			 {
			    //if block
			 	case 1:
			 	case 2:
			 	   break;
			 	//switch block
			 	case 3:
			 	   break;
			    //case block
			 	case 4:
			 	case 5:
			 		if(line.indexOf("{") >= 0)
			 		{
				 	   blockType = 0;
				 	   break;
			 		}
				 	else/* because(line.indexOf("break;") >= 0) */
				 	   endedBlock = true;
			 		break;
			 }
			 currPath += meth[i] + "\n";
			 //when you're done you're done
			/* because(endedBlock) */
			 {
				 paths.add(currPath);
				 pcpLineNo++;
				 return paths;
			 }
			 relativeLine++;
			 pcpLineNo++;
		  }
		  paths.add(currPath);
		  return paths;
	   }

=========================
256 total tests.
